# Custom Pipeline

Pipeline is the core of genapi. You can create custom pipelines to fully control the API generation process.

## Pipeline System

genapi's pipeline system consists of multiple stages:

1. **config** - Read and transform configuration
2. **original** - Get original data source
3. **parser** - Parse data source into data graph
4. **compiler** - Compile data into abstract syntax tree (AST)
5. **generate** - Generate code string
6. **dest** - Output files

## Creating Custom Pipeline

```ts
import { defineConfig } from '@genapi/core'
import pipeline, { compiler, dest, generate, original } from '@genapi/pipeline'
import { axios } from '@genapi/presets'

export default defineConfig({
  preset: pipeline(
    // read config, convert to internal config, and provide default values
    config => axios.ts.config(config),
    // get data source
    configRead => original(configRead),
    // parse the data source as data graphs
    configRead => axios.ts.parser(configRead),
    // compile data and convert it into abstract syntax tree (AST)
    configRead => compiler(configRead),
    // generate code string
    configRead => generate(configRead),
    // use outputs to output files
    configRead => dest(configRead),
  ),
})
```

## Custom Parser

You can replace the processing logic of any stage:

```ts
import { defineConfig } from '@genapi/core'
import { parser } from '@genapi/parser'
import pipeline, { compiler, dest, generate, original } from '@genapi/pipeline'

export default defineConfig({
  preset: pipeline(
    config => config,
    configRead => original(configRead),
    // use custom parser
    configRead => parser(configRead),
    configRead => compiler(configRead),
    configRead => generate(configRead),
    configRead => dest(configRead),
  ),
})
```

## Custom Generator

You can also customize code generation logic:

```ts
import { defineConfig } from '@genapi/core'
import pipeline, { compiler, dest, generate, original } from '@genapi/pipeline'

// Custom generate function
function customGenerate(configRead) {
  // Custom code generation logic
  return generate(configRead)
}

export default defineConfig({
  preset: pipeline(
    config => config,
    configRead => original(configRead),
    configRead => parser(configRead),
    configRead => compiler(configRead),
    configRead => customGenerate(configRead),
    configRead => dest(configRead),
  ),
})
```

## Pipeline Composition

You can combine multiple pipeline stages to implement complex logic:

```ts
import { defineConfig } from '@genapi/core'
import pipeline from '@genapi/pipeline'

export default defineConfig({
  preset: pipeline(
    // Stage 1: Configuration processing
    config => processConfig(config),
    // Stage 2: Data fetching
    configRead => fetchData(configRead),
    // Stage 3: Data transformation
    configRead => transformData(configRead),
    // ... more stages
  ),
})
```

## Best Practices

1. **Reuse existing presets**: Try to extend based on existing presets
2. **Keep stages independent**: Each stage should only be responsible for one responsibility
3. **Error handling**: Add error handling logic at critical stages
4. **Type safety**: Use TypeScript to ensure type safety
