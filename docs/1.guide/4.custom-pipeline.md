# Custom Pipeline

Pipeline is the core of genapi. You can create custom pipelines to fully control the API generation process.

## Pipeline System

genapi's pipeline system consists of multiple stages:

1. **config** - Read and transform configuration
2. **original** - Get original data source
3. **parser** - Parse data source into data graph
4. **compiler** - Compile data into abstract syntax tree (AST)
5. **generate** - Generate code string
6. **dest** - Output files

## Creating Custom Pipeline

```ts
import { defineConfig } from '@genapi/core'
import pipeline, { compiler, dest, generate, original } from '@genapi/pipeline'
import { axios } from '@genapi/presets'

export default defineConfig({
  preset: pipeline(
    // read config, convert to internal config, and provide default values
    config => axios.ts.config(config),
    // get data source
    configRead => original(configRead),
    // parse the data source as data graphs
    configRead => axios.ts.parser(configRead),
    // compile data and convert it into abstract syntax tree (AST)
    configRead => compiler(configRead),
    // generate code string
    configRead => generate(configRead),
    // use outputs to output files
    configRead => dest(configRead),
  ),
})
```

## Custom Parser

You can replace any stage. For the parser stage, use a preset's parser (e.g. `axios.ts.parser`) or build your own with `createParser` from `@genapi/parser`:

```ts
import { defineConfig } from '@genapi/core'
import pipeline, { compiler, dest, generate, original } from '@genapi/pipeline'
import { axios } from '@genapi/presets'

export default defineConfig({
  preset: pipeline(
    config => axios.ts.config(config),
    configRead => original(configRead),
    configRead => axios.ts.parser(configRead), // or your custom parser
    configRead => compiler(configRead),
    configRead => generate(configRead),
    configRead => dest(configRead),
  ),
})
```

## Custom Generator

You can wrap or replace the generate stage:

```ts
import { defineConfig } from '@genapi/core'
import pipeline, { compiler, dest, generate, original } from '@genapi/pipeline'
import { axios } from '@genapi/presets'

function customGenerate(configRead) {
  // Customize then call default generate
  return generate(configRead)
}

export default defineConfig({
  preset: pipeline(
    config => axios.ts.config(config),
    configRead => original(configRead),
    configRead => axios.ts.parser(configRead),
    configRead => compiler(configRead),
    configRead => customGenerate(configRead),
    configRead => dest(configRead),
  ),
})
```

## Pipeline Composition

Each stage receives the previous result; combine them to implement custom logic:

```ts
import { defineConfig } from '@genapi/core'
import pipeline, { compiler, dest, generate, original } from '@genapi/pipeline'
import { axios } from '@genapi/presets'

export default defineConfig({
  preset: pipeline(
    config => axios.ts.config(config),
    configRead => original(configRead),
    configRead => axios.ts.parser(configRead),
    configRead => compiler(configRead),
    configRead => generate(configRead),
    configRead => dest(configRead),
  ),
})
```

## Best Practices

1. **Reuse existing presets**: Try to extend based on existing presets
2. **Keep stages independent**: Each stage should only be responsible for one responsibility
3. **Error handling**: Add error handling logic at critical stages
4. **Type safety**: Use TypeScript to ensure type safety
